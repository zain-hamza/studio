/**
 * @fileoverview Firestore Security Rules for Career Clarity application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model, ensuring that users can only
 * read and write their own data, with the exception of public profile information.
 *
 * Data Structure:
 * - /users/{userId}: Stores public profile information for each user.  Only the
 *   authenticated user can create their profile.  The 'userId' segment must match
 *   the authenticated user's UID.
 * - /users/{userId}/savedRoles/{roleId}: A subcollection under each user's document
 *   that stores career roles saved by that user. Only the authenticated user can
 *   manage their saved roles.
 *
 * Key Security Decisions:
 * - User profiles are created upon first sign-in and are owned by the respective user.
 * - Listing all users is disallowed to prevent information harvesting.
 * - The rules validate that the 'userId' path segment matches the authenticated user's UID
 *   for all operations under the /users/{userId} path, ensuring data consistency.
 *
 * Denormalization for Authorization:
 *  - The rules rely on path-based authorization. The path `/users/{userId}` inherently
 *    associates the data with a specific user.  No additional denormalization is required
 *    in this simple example.
 *
 * Structural Segregation:
 *  - User profiles and saved roles are kept separate to maintain a clear data model and
 *    improve query performance. There is no need for public vs. private segregation
 *    in this case.
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile access.  Users can read and update their own profiles.
     * @path /users/{userId}
     * @allow (create) - Authenticated user with UID matching {userId} can create their profile. e.g., request.auth.uid == "user123" creating /users/user123.
     * @allow (get) - Authenticated user can get their own profile.
     * @allow (update) - Authenticated user can update their own profile.
     * @allow (delete) - Authenticated user can delete their own profile.
     * @deny (create) - Authenticated user cannot create a profile with a mismatched {userId}. e.g., request.auth.uid == "user456" trying to create /users/user123.
     * @deny (get) - Any unauthenticated user.
     * @deny (update) - Any unauthenticated user.
     * @deny (delete) - Any unauthenticated user.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && isValidUserCreation();
      allow update: if isSignedIn() && isExistingOwner(userId) && isUserProfileUpdateValid();
      allow delete: if isSignedIn() && isExistingOwner(userId);

      /**
       * @description Manages access to saved career roles for a user.  Users can only access their own saved roles.
       * @path /users/{userId}/savedRoles/{roleId}
       * @allow (create) - Authenticated user with UID matching {userId} can create a saved role. e.g., request.auth.uid == "user123" creating /users/user123/savedRoles/role1.
       * @allow (get) - Authenticated user can get their own saved role.
       * @allow (list) - Authenticated user can list their own saved roles.
       * @allow (update) - Authenticated user can update their own saved role.
       * @allow (delete) - Authenticated user can delete their own saved role.
       * @deny (create) - Authenticated user cannot create a saved role with a mismatched {userId}. e.g., request.auth.uid == "user456" trying to create /users/user123/savedRoles/role1.
       * @deny (get) - Any unauthenticated user.
       * @deny (list) - Any unauthenticated user.
       * @deny (update) - Any unauthenticated user.
       * @deny (delete) - Any unauthenticated user.
       * @principle Enforces document ownership for saved roles.
       */
      match /savedRoles/{roleId} {
        allow get: if isSignedIn() && isOwner(userId);
        allow list: if isSignedIn() && isOwner(userId);
        allow create: if isSignedIn() && isOwner(userId);
        allow update: if isSignedIn() && isExistingOwner(userId);
        allow delete: if isSignedIn() && isExistingOwner(userId);
      }
    }
  }
}

/**
 * @description Checks if the user is signed in.
 * @return {bool} True if the user is signed in, false otherwise.
 */
function isSignedIn() {
  return request.auth != null;
}

/**
 * @description Checks if the user is the owner of the resource.
 * @param {string} userId The user ID to check.
 * @return {bool} True if the user is the owner, false otherwise.
 */
function isOwner(userId) {
  return request.auth.uid == userId;
}

/**
 * @description Checks if the user is the owner of the resource, and the resource exists.
 * @param {string} userId The user ID to check.
 * @return {bool} True if the user is the owner and the resource exists, false otherwise.
 */
function isExistingOwner(userId) {
  return isOwner(userId) && resource != null;
}

/**
 * @description Validates if the user profile creation request is valid.  Specifically, that
 * the ID in the document matches the userId in the path.
 * @return {bool} True if the profile creation is valid, false otherwise.
 */
function isValidUserCreation() {
  return request.resource.data.email is string;
}

/**
 * @description Validates if the user profile update request is valid.
 * Enforces that `email` cannot be changed after initial creation.
 * @return {bool} True if the profile update is valid, false otherwise.
 */
function isUserProfileUpdateValid() {
    return request.resource.data.email == resource.data.email;
}